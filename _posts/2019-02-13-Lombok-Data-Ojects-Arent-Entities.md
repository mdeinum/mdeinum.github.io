---
layout: post
title: "Data Objects aren't entities"
date: 2019-02-13
categories:
- Java
tags:
- lombok
- code generation
published: false
---
When using a framework like [Lombok](https://projectlombok.org/) it is very tempting and eays to use its [`@Data`](https://projectlombok.org/features/Data) annotation.

> All together now: A shortcut for `@ToString`, `@EqualsAndHashCode`, `@Getter` on all fields, `@Setter` on all non-final fields, and `@RequiredArgsConstructor`! (Source: Lombok Documentation)

When placing the convinient `@Data` annotation on an `@Entity` annotated class that might look like a nice idea.
Give the following 2 entities, `Book` and `Author` lets illustrate what the challenges.

```java
@Data
@Entity
public class Book {

    @Id
    @GeneratedValue
    private Long id;
    private String isbn;
    private String title;

    @ManyToMany(cascade = { CascadeType.ALL })
    @JoinTable(
        name = "Book_Author",
        joinColumns = { @JoinColumn(name = "author_id") },
        inverseJoinColumns = { @JoinColumn(name = "book_id") }
    )
    private List<Author> authors;
}

@Data
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Long id;
  private String name;
  @ManyToMany(mappedBy="authors")
  private List<Book> books;  
}
```

As mentioned in the Lombok documentation it will generate all getters/setters, `toString`, `equals` and `hashCode`. The main problem lies in the generation of the `equals` and `hashCode` implementation.

However there also lies a problem in the generated `toString` method.

## The generated `equals` and `hashCode` methods
When using a technology like JPA the [object identity shouldn't change between state transitions](https://vladmihalcea.com/hibernate-facts-equals-and-hashcode/) or property updates. If the book title changes, due to a typo, it still is the same book entity. However not if you use the generated `equals` and `hashCode` methods.

### Solution
Use a base class that implements the `hashCode` and `equals` method, which are safe for entities. Something like [Vlad Mihalcea proposes in his blog](https://vladmihalcea.com/how-to-implement-equals-and-hashcode-using-the-jpa-entity-identifier/)

```java
@MappedSuperClass
public abstract class BaseEntity {

    @Id
    @GeneratedValue
    private Long id;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof getClass())) return false;
        BaseEntity that = (BaseEntity) o;
        return this.id != null && Objects.equals(this.id, that.id);
    }

    @Override
    public int hashCode() {
        return 31;
    }}
}
```

Now when `Book` extends the `BaseEntity` Lombok will backoff in generating the `equals` method, as we provide one ourself. The same applies to the `hashCode` method.

## The generated `toString` method
There might be an issue when using the default `toString` method. Not with simple entities but when entities that reference other entities or in a collection.

The default `toString` generated by Lombok includes **ALL** the fields in the entity. This will lead to 2 issues when using the `toString` method.

1. Eager fetching of collections
2. Stackover flow when trying to print using `toString` due to bi-directional dependency.

The `authors` field is part of the `toString` and will lead to a query, to retrieve the authors. Thus eagerly fetching the collection.

The `Author` has a collection of `Book` entities, which will be retrieved as well and printed to the `toString`. Each `Book` will have its `toString` called, leading to calling `toString` on each `Author` again, and so on, and on, and on, and on until you get a `StackOverflowError`.

### Solution
There are 2 possible solutions:

1. Create your own `toString` method, Lombok will then backoff generating a `toString`
```java
@Data
@Entity
public class Book {

    @Id
    @GeneratedValue
    private Long id;
    private String isbn;
    private String title;

    @ManyToMany(cascade = { CascadeType.ALL })
    @JoinTable(
        name = "Book_Author",
        joinColumns = { @JoinColumn(name = "author_id") },
        inverseJoinColumns = { @JoinColumn(name = "book_id") }
    )
    private List<Author> authors;

    public String toString() {
      return String.format("Book [id=%d, isbn=%s, title=%s]", this.id, this.isbn, this.title);      
    }
}
```
2. Add the [`@ToString`](https://projectlombok.org/features/ToString) annotation and exclude all the lazy and bi-directional fields using `@ToString.Exclude`.

```java
@Data
@ToString
@Entity
public class Book {

    @Id
    @GeneratedValue
    private Long id;
    private String isbn;
    private String title;

    @ManyToMany(cascade = { CascadeType.ALL })
    @JoinTable(
        name = "Book_Author",
        joinColumns = { @JoinColumn(name = "author_id") },
        inverseJoinColumns = { @JoinColumn(name = "book_id") }
    )
    @ToString.Exclude
    private List<Author> authors;
}
```

## Conclusion
You can use the `@Data` annotation from Lombok with `@Entity` objects, however there are somethings you need to take into account.

1. Always write your own `equals` and `hashCode` methods that properly works for JPA. You might want to include these in a base entity you extend.
2. Be cautious in what to include in the generated `toString`. You might want to include a default `toString` in a base entity class.
3. Because of 1 and 2 you might be better of just using the `@Getter` / `@Setter` annotations instead of the `@Data` annotation. As that is what generally is needed/wanted. 
